// Copyright (c) 2024ï¼ŒD-Robotics.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*
 *    COPYRIGHT NOTICE
 *   Copyright 2019 Horizon Robotics, Inc.
 *    All rights reserved.
 */

#ifndef __HB_DS954_SETTING_H__
#define __HB_DS954_SETTING_H__

#ifdef __cplusplus
extern "C" {
#endif

static uint32_t ds954_ov10635_init_setting[] = {
	0x01, 0x03,  // Digital reset 0/1.
	0x1f, 0x02 ,  // CSI0 800mbps
	0x33, 0x61 ,  // CSI_EN & CSI0 2L
	0x20, 0x30 ,  // disable port forward
	0x41, 0xA9 ,  // fix mismatch
	/* RX_PORT0 */
	0x4c, 0x01 ,  // RX_PORT0
	0x58, 0x58 ,  // enable pass throu
	0x5c, 0x38 ,  // serializer alias 0x1c
	0x5d, 0x60 ,  //
	0x65, 0x80 ,  // slave alias 0x40
	0x7c, 0x81 ,  // FV active low 8bit
	0x70, 0x1E ,  // VC0 and CSI0 datatype 0x1e yuv422_8b
	0x6d, 0x7F ,  // 913A 10-bit mode, FPD_MODE
	0x72, 0x00,
	/* RX_PORT1 */
	0x4c, 0x12 ,  // RX_PORT0
	0x58, 0x58 ,  // enable pass throu
	0x5c, 0x3a ,  // 913 alias addr 0x1d
	0x5d, 0x60 ,  //
	0x65, 0x82 ,  // 10635 alias 0x41
	0x7c, 0x81 ,  // FV active low 8bit
	0x70, 0x5E ,  // VC1 and CSI0 datatype 0x1e yuv422_8b
	0x6d, 0x7F ,  // 913A 10-bit mode, FPD_MODE
	0x72, 0x55,
};

static uint32_t ds954_ar0239_init_setting[] = {
    0x1f, 0x03 ,  // CSI0 400mbps
    0x33, 0x41 ,  // CSI_EN & CSI0 4L
    0x20, 0x30 ,  // forwarding all RX to CSI0
    /* RX_PORT0 */
    0x4c, 0x01 ,  // RX_PORT0
    0x58, 0x58 ,  // enable pass throu
    0x5c, 0x38,  // "SER_ALIAS_ID 0x5c value ", hex board.ReadReg 0x5c
    0x5d, 0x60 ,  // "SlaveID[0] 0x5d value ", hex board.ReadReg 0x5d
    0x65, 0x80 ,  // "SlaveAlias[0] 0x65 value ", hex board.ReadReg 0x65
    0x7c, 0xC1 ,  // FV active low 8bit
    0x70, 0x1E ,  // VC0 and CSI0 datatype 0x1e yuv422_8b
    0x6d, 0x7F ,  // 913A 10-bit mode, FPD_MODE
};

static uint32_t ds954_ar0239_stream_on[] = {
	0x20, 0x20 ,   // forwarding all RX to CSI0
	//  0x00 for PORT0 && PORT1; 0x20 for PORT0; Ox10 for PORT1
};
static uint32_t ds954_ar0239_stream_off[] = {
	0x20, 0x30
};

static uint32_t ds954_imx390_init_setting[] = {
	0x01, 0x03,     // DIGITAL_RESET

	/* common cfg */
	0x1f, 0x02,     // 0x02 800Mbps, 0x10 1.6Gbps
	0x33, 0x23,     // 0x0x 4 lanes, 0x2x 2 lanes
	// & enable csi output & continuous clock
	0x20, 0x00,     // Forwarding enable rx port 0 & 1

	/* rx port 0 */
	0x4C, 0x01,     // Write Enable for RX port 0 registers
	0x58, 0xDE,     // BCC_CONFIG
	0x5C, 0x30,     // SER_ALIAS_ID
	0x5D, 0x42,     // SlaveID[0]  sensor i2c addr
	0x65, 0x42,     // SlaveAlias[0] sensor i2c alias addr
	0x6E, 0x99,     // BC_GPIO1_SEL/BC_GPIO0_SEL  Constant value of 1
	0x6F, 0x00,     // BC_GPIO_CTL1

	/* rx port 1 */
	0x4C, 0x12,     // Write Enable for RX port 1 registers
	0x58, 0xDE,     // BCC_CONFIG
	0x5C, 0x30,     // SER_ALIAS_ID
	0x5D, 0x42,     // SlaveID[0]  sensor i2c addr
	0x65, 0x42,     // SlaveAlias[0] sensor i2c alias addr
	0x6E, 0x99,     // BC_GPIO1_SEL/BC_GPIO0_SEL  Constant value of 1
	0x6F, 0x00,     // BC_GPIO_CTL1

	/* common cfg */
	0x0F, 0x63,     // gpio0/1/5/6 input enable
	0x10, 0x00,     // GPIO0_PIN_CTL
	0x11, 0x04,     // GPIO1_PIN_CTL
	0x12, 0x09,     // GPIO2_PIN_CTL
	0x14, 0x0D,     // GPIO4_PIN_CTL
};

static uint32_t ds954_imx390_alias_init_setting[] = {
	0x01, 0x03,
	0x4C, 0x01,
	0x21, 0x81,
	0x33, 0x23,
	0x20, 0x20,
	0x42, 0x71,
	0x5C, 0x30,
	0x5D, 0x42,
	0x65, 0x42,
	0x6E, 0x99,
	0x58, 0xDE,
	0x6D, 0x44,
	0xD5, 0xF0,
	0x0F, 0x63,
	0x10, 0x00,
	0x11, 0x04,
	0x12, 0x09,
	0x14, 0x0D,
	0x6F, 0x00,
};

static uint32_t ds954_imx390_rcm_init_setting[] = {
	0x01, 0x03,     // DIGITAL_RESET
	0x4C, 0x01,     // Write Enable for RX port 0 registers
	0x21, 0x81,     // FWD_CTL2  Round robin forwarding enabled
	0x33, 0x23,     // 2 lanes & enable csi output & continuous clock
	0x20, 0x20,     // Forwarding disabled RX Port 1 & enable rx port 0
	0x42, 0x71,
	0x5C, 0x30,     // SER_ALIAS_ID
	0x5D, 0x34,     // SlaveID[0]  sensor i2c addr
	0x65, 0x34,     // S laveAlias[0] sensor i2c alias addr
	0x6E, 0x99,     // BC_GPIO1_SEL/BC_GPIO0_SEL  Constant value of 1
	0x58, 0xDE,     // BCC_CONFIG
	0x6D, 0x44,     // PORT_CONFIG - Do not forward packets with errors & CSI Mode
	0xD5, 0xF0,
	0x0F, 0x63,     // gpio0/1/5/6 input enable
	0x10, 0x00,     // GPIO0_PIN_CTL
	0x11, 0x04,     // GPIO1_PIN_CTL
	0x12, 0x09,     // GPIO2_PIN_CTL
	0x14, 0x0D,     // GPIO4_PIN_CTL
	0x6F, 0x00,     // BC_GPIO_CTL1
};

static uint32_t ds954_mono_init_setting[] = {
	0x01, 0x03,     // DIGITAL_RESET
	0x4C, 0x01,     // Write Enable for RX port 0 registers
	0x21, 0x81,     // FWD_CTL2  Round robin forwarding enabled
	0x33, 0x23,     // 2 lanes & enable csi output & continuous clock
	0x20, 0x20,     // Forwarding disabled RX Port 1 & enable rx port 0
	0x42, 0x71,
	0x5C, 0x30,     // SER_ALIAS_ID
	0x5D, 0x42,     // SlaveID[0]  sensor i2c addr
	0x65, 0x42,     // S laveAlias[0] sensor i2c alias addr
	0x6E, 0x99,     // BC_GPIO1_SEL/BC_GPIO0_SEL  Constant value of 1
	0x58, 0xDE,     // BCC_CONFIG
	0x6D, 0x44,     // PORT_CONFIG - Do not forward packets with errors & CSI Mode
	0xD5, 0xF0,
	0x0F, 0x63,     // gpio0/1/5/6 input enable
	0x10, 0x00,     // GPIO0_PIN_CTL
	0x11, 0x04,     // GPIO1_PIN_CTL
	0x12, 0x09,     // GPIO2_PIN_CTL
	0x14, 0x0D,     // GPIO4_PIN_CTL
	0x6F, 0x00,     // BC_GPIO_CTL1
};
static uint32_t ds954_ar0233_init_setting[] =
{
	0x01, 0x03, 	// DIGITAL_RESET
	0x4C, 0x01, 	// Write Enable for RX port 0 registers
	0x21, 0x81, 	// FWD_CTL2  Round robin forwarding enabled
	0x33, 0x21, 	// 2 lanes & enable csi output & continuous clock
	0x20, 0x20, 	// Forwarding disabled RX Port 1 & enable rx port 0
	0x42, 0x71,
	0x5C, 0x30, 	// SER_ALIAS_ID
	0x5D, 0x20, 	// SlaveID[0]  sensor i2c addr
	0x65, 0x20, 	// S laveAlias[0] sensor i2c alias addr
	0x6E, 0x99, 	// BC_GPIO1_SEL/BC_GPIO0_SEL  Constant value of 1
	0x58, 0xDE, 	// BCC_CONFIG
	0x6D, 0x44, 	// PORT_CONFIG - Do not forward packets with errors & CSI Mode
	0xD5, 0xF0,
	0x0F, 0x63, 	// gpio0/1/5/6 input enable
	0x10, 0x00, 	// GPIO0_PIN_CTL
	0x11, 0x04, 	// GPIO1_PIN_CTL
	0x12, 0x09, 	// GPIO2_PIN_CTL
	0x14, 0x0D, 	// GPIO4_PIN_CTL
	0x6F, 0x00, 	// BC_GPIO_CTL1
};

static uint32_t ds954_ar0233_x3_4lane_init_setting[] =
{
	0x01, 0x03,  // Digital reset 0/1.
	0x1f, 0x02,  // csi 800Mbps.
	0x33, 0x01,  // csi enable: 4lane, no-continue, normal LP0.
	0x34, 0x40,  // csi pass mode one, no invert seq, no single seq.
	0x41, 0xA9,  // fix mismtach!!
	/***port0***/
	0x4C, 0x01,  // port sel: port0 rw.
	0x58, 0x5E,  // i2c pass through, Back channel always on, crc, 50M.
	0x5C, 0x30,  // SER_ALIAS_ID=0x18.
	0x5D, 0x20,  // SLAVE_ID[0]=0x10.
	0x5E, 0xD0,  // SLAVE_ID[1]=0x68.
	0x65, 0x20,  // SLAVE_ALIAS[0]=0x10.
	0x66, 0xD0,  // SLAVE_ALIAS[1]=0x68.
	0x6E, 0x99,  // bc gpio: 1-val1, 0-val1;
	0x6d, 0x44,  // csi mode.
	0x72, 0x00,  // all map to VC0.
	/***port1***/
	0x4C, 0x12,  // port sel: port1 rw.
	0x58, 0x5E,  // i2c pass through, Back channel always on, crc, 50M.
	0x5C, 0x32,  // SER_ALIAS_ID=0x19.
	0x5D, 0x20,  // SLAVE_ID[0]=0x10.
	0x5E, 0xD0,  // SLAVE_ID[1]=0x68.
	0x65, 0x22,  // SLAVE_ALIAS[0]=0x11.
	0x66, 0xD2,  // SLAVE_ALIAS[1]=0x69.
	0x6E, 0x99,  // bc gpio: 1-val1, 0-val1;
	0x6d, 0x44,  // csi mode.
	0x72, 0x55,  // all map to VC1.
	/***forward***/
	0x20, 0x30   // disable all when init
};

static uint32_t ds954_ar0233_x3_2lane_init_setting[] =
{
	0x01, 0x03,  // Digital reset 0/1.
	0x1f, 0x00,  // csi 1600M
	0x33, 0x21,  // csi enable: 2lane, no-continue, normal LP0.
	0x34, 0x40,  // csi pass mode one, no invert seq, no single seq.
	0x41, 0xA9,  // fix mismtach!!
	/***port0***/
	0x4C, 0x01,  // port sel: port0 rw.
	0x58, 0x5E,  // i2c pass through, Back channel always on, crc, 50M.
	0x5C, 0x30,  // SER_ALIAS_ID=0x18.
	0x5D, 0x20,  // SLAVE_ID[0]=0x10.
	0x5E, 0xD0,  // SLAVE_ID[1]=0x68.
	0x65, 0x20,  // SLAVE_ALIAS[0]=0x10.
	0x66, 0xD0,  // SLAVE_ALIAS[1]=0x68.
	0x6E, 0x99,  // bc gpio: 1-val1, 0-val1;
	0x6d, 0x44,  // csi mode.
	0x72, 0x00,  // all map to VC0.
	/***port1***/
	0x4C, 0x12,  // port sel: port1 rw.
	0x58, 0x5E,  // i2c pass through, Back channel always on, crc, 50M.
	0x5C, 0x32,  // SER_ALIAS_ID=0x19.
	0x5D, 0x20,  // SLAVE_ID[0]=0x10.
	0x5E, 0xD0,  // SLAVE_ID[1]=0x68.
	0x65, 0x22,  // SLAVE_ALIAS[0]=0x11.
	0x66, 0xD2,  // SLAVE_ALIAS[1]=0x69.
	0x6E, 0x99,  // bc gpio: 1-val1, 0-val1;
	0x6d, 0x44,  // csi mode.
	0x72, 0x55,  // all map to VC1.
	/***forward***/
	0x20, 0x30	 // disable all when init
};

static uint32_t ds954_ar0233_zu3_init_setting[] =
{
	0x01, 0x03,  // Digital reset 0/1.
	0x1f, 0x03,  // csi 400Mbps.
	0x33, 0x03,  // csi enable: 4lane, no-continue, normal LP0.
	0x34, 0x40,  // csi pass mode one, no invert seq, no single seq.
	0x41, 0xA9,  // fix mismtach!!
	/***port0***/
	0x4C, 0x01,  // port sel: port0 rw.
	0x58, 0x5E,  // i2c pass through, Back channel always on, crc, 50M.
	0x5C, 0x30,  // SER_ALIAS_ID=0x18.
	0x5D, 0x20,  // SLAVE_ID[0]=0x10.
	0x5E, 0xD0,  // SLAVE_ID[1]=0x68.
	0x65, 0x20,  // SLAVE_ALIAS[0]=0x10.
	0x66, 0xD0,  // SLAVE_ALIAS[1]=0x68.
	0x6E, 0x99,  // bc gpio: 1-val1, 0-val1;
	0x6d, 0x44,  // csi mode.
	0x72, 0x00,  // all map to VC0.
	/***port1***/
	0x4C, 0x12,  // port sel: port1 rw.
	0x58, 0x5E,  // i2c pass through, Back channel always on, crc, 50M.
	0x5C, 0x32,  // SER_ALIAS_ID=0x19.
	0x5D, 0x20,  // SLAVE_ID[0]=0x10.
	0x5E, 0xD0,  // SLAVE_ID[1]=0x68.
	0x65, 0x22,  // SLAVE_ALIAS[0]=0x11.
	0x66, 0xD2,  // SLAVE_ALIAS[1]=0x69.
	0x6E, 0x99,  // bc gpio: 1-val1, 0-val1;
	0x6d, 0x44,  // csi mode.
	0x72, 0x55,  // all map to VC1.
	/***forward***/
	0x20, 0x30   // disable all when init
};

static uint32_t ds954_start_setting[] =
{
	0x20, 0x00,  // forward: Rx1-enable, Rx0-enable.
};

static uint32_t ds954_dummy_init_setting[] =
{
	0x01, 0x03,  // Digital reset 0/1.
	0x1f, 0x02,  // csi 800Mbps.
	0x33, 0x01,  // csi enable: 4lane, no-continue, normal LP0.
	0x34, 0x40,  // csi pass mode one, no invert seq, no single seq.
	0x41, 0xA9,  // fix mismtach!!
	/***port0***/
	0x4C, 0x01,  // port sel: port0 rw.
	0x58, 0x5E,  // i2c pass through, Back channel always on, crc, 50M.
	0x5C, 0x30,  // SER_ALIAS_ID=0x18.
	0x6d, 0x44,  // csi mode.
	0x72, 0x00,  // all map to VC0.
	/***port1***/
	0x4C, 0x12,  // port sel: port1 rw.
	0x58, 0x5E,  // i2c pass through, Back channel always on, crc, 50M.
	0x5C, 0x32,  // SER_ALIAS_ID=0x19.
	0x6d, 0x44,  // csi mode.
	0x72, 0x55,  // all map to VC1.
	/***forward***/
	0x20, 0x30   // disable all when init
};

static uint32_t ds954_dummy_start_setting[] =
{
	0x20, 0x00,  // forward: Rx1-enable, Rx0-enable.
};

static uint32_t ds954_dummy_stop_setting[] =
{
	0x20, 0x30,  // forward: Rx1-disable, Rx0-disable.
};

static uint32_t ds954_mult_init_setting[] = {
	0x1f, 0x03 ,   // CSI0 800mbps
	0x33, 0x61 ,   // CSI_EN & CSI0 4L
	0x20, 0x30 ,   // forwarding all RX to CSI0

	/* RX_PORT0 */
	0x4c, 0x01 ,   // RX_PORT0
	0x58, 0x58 ,   // enable pass throu
	//0x5c, 0x38 , // "SER_ALIAS_ID 0x5c value ", hex board.ReadReg 0x5c
	0x5c, 0x38,
	0x5d, 0x60 ,   // "SlaveID[0] 0x5d value ", hex board.ReadReg 0x5d
	//0x65, 0x80 , // "SlaveAlias[0] 0x65 value ", hex board.ReadReg 0x65
	0x65, 0x80 ,
	0x7c, 0xC0 ,   // FV active low 8bit
	0x70, 0x1E ,   // VC0 and CSI0 datatype 0x1e yuv422_8b
	0x6d, 0xFF ,   // 913A 10-bit mode, FPD_MODE

	/* RX_PORT1 */
	0x4c, 0x12 ,   // RX_PORT1
	0x58, 0x58 ,   // enable pass throu
	// 0x5c, 0x3a ,   // "SER_ALIAS_ID 0x5c value ", hex board.ReadReg 0x5c
	0x5c, 0x3a ,
	0x5d, 0x60 ,   // "SlaveID[0] 0x5d value ", hex board.ReadReg 0x5d
	// 0x65, 0x82 ,   // "SlaveAlias[0] 0x65 value ", hex board.ReadReg 0x65
	0x65, 0x82 ,
	0x7c, 0xC0 ,   // FV active low 8bit
	0x70, 0x5E ,   // VC1 and CSI0 datatype 0x1e yuv422_8b
	0x6d, 0xFF ,   // 913A 10-bit mode, FPD_MODE
};

static uint32_t ds954_mult_start_setting[] = {
	0x20, 0x20 ,
};

static uint32_t ds954_mult_stop_setting[] = {
	0x20, 0x30 ,
};

static uint32_t ds954_mult02_init_setting[] = {
	0x1f, 0x03 ,  // CSI0 400mbps
	0x33, 0x41 ,  // CSI_EN & CSI0 4L
	0x20, 0x30 ,  // disable forwarding all RX to CSI0
	// 0x21, 0x3c,

	/* RX_PORT0 10635 */
	0x4c, 0x01 ,  // RX_PORT0
	0x58, 0x58 ,  // enable pass throu
	0x5c, 0x08 ,  // 913 alias addr 0x04
	0x5d, 0x60 ,  // 10635 slave 0x30
	0x65, 0x80 ,  // 10635 alias addr 0x40
	0x7c, 0x81 ,  // FV active low 8bit
	0x70, 0x1E ,  // VC1 and CSI0 datatype 0x1e yuv422_8b
	0x6d, 0xFF ,  // 913A 10-bit mode, FPD_MODE
	0x72, 0x00,

	/* RX_PORT1 10635 */
	0x4c, 0x12 ,  // RX_PORT1
	0x58, 0x58 ,  // enable pass throu
	0x5c, 0x0c ,  // 913 alias addr 0x05
	0x5d, 0x60 ,  // 10635 slave 0x30
	0x65, 0x84 ,  // 10635 alias 0x42
	0x7c, 0x81 ,  // FV active low 8bit
	0x70, 0x5E ,  // VC0 and CSI0 datatype 0x1e yuv422_8b
	0x6d, 0xFF ,  // 913A 10-bit mode, FPD_MODE
	0x72, 0x55,
};
static uint32_t ds954_mult02_stream_off[] = {
	0x20, 0x30
};
static uint32_t ds954_mult02_stream_on[] = {
	0x20, 0x00
};

static uint32_t ds954_ar0144_init_setting[] = {
	/* COMMON CFG */
	0x1f, 0x03,
	0x33, 0x61,
	0x20, 0x30,
	/* RX_PORT0 */
	0x4c, 0x01 ,  // RX_PORT0
	0x58, 0x58 ,  // enable pass throu
	0x5c, 0xb0 ,  // "SER_ALIAS_ID 0x5c value ", hex board.ReadReg 0x5c
	0x5d, 0xa0 ,  // "SlaveID[0] 0x5d value ", hex board.ReadReg 0x5d
	0x65, 0x80 ,  // "SlaveAlias[0] 0x65 value ", hex board.ReadReg 0x65
	0x7c, 0xC0 ,  // FV active low 8bit
	0x70, 0x1E ,  // VC1 and CSI0 datatype 0x1e yuv422_8b
	0x6d, 0xFF ,  // 913A 10-bit mode, FPD_MODE
};

static uint32_t ds954_ar0144_start_setting[] = {
	0x20, 0x20,
};

static uint32_t ds954_ar0144_stop_setting[] = {
	0x20, 0x30,
};

static uint32_t ds954_ar0143_init_setting[] = {
	/* COMMON CFG */
	0x1f, 0x03,
	0x33, 0x61,
	0x20, 0x30,
	/* RX_PORT0 */
	0x4c, 0x01,
	0x58, 0x58,
	0x5c, 0x38,
	0x5d, 0x60,
	0x65, 0x80,
	0x7c, 0xC0,
	0x70, 0x1E,
	0xbc, 0x00,
	0x6d, 0x7F
};

static uint32_t ds954_ar0143_start_setting[] = {
	0x20, 0x20,
};

static uint32_t ds954_ar0143_stop_setting[] = {
	0x20, 0x30,
};


static uint32_t ds954_ix019_init_setting[] = {
	0x01,  0x03,   // DIGITAL_RESET
	/* COMMON CFG */
	0x1f, 0x02,   // CSI0 800mbps
	0x33, 0x43,
	0x20, 0x30,
	/* RX_PORT0 */
	0x4c, 0x01,
	0x58, 0x58,
	0x5c, 0x38,
	0x5d, 0x60,
	0x65, 0x80,
	0x7c, 0xC0,
	0x70, 0x1E,
	0xbc, 0x00,
	0x6d, 0x7F,
};

static uint32_t ds954_ix019_bypass_init_setting[] = {
	0x01, 0x03,   // DIGITAL_RESET
	/* COMMON CFG */
	0x1f, 0x02,   // CSI0 800mbps
	0x33, 0x43,
	0x20, 0x30,
	/* RX_PORT0 */
	0x4c, 0x01,
	0x58, 0x5E,
	0x5c, 0x30,
	0x5d, 0x60,
	0x65, 0x80,
	0x7c, 0xC0,
	0x70, 0x1E,
	0xbc, 0x00,
	0x6d, 0x7C,
};

static uint32_t ds954_ix019_bypass_start_setting[] = {
	0x20, 0x00,
};

static uint32_t ds954_ix019_start_setting[] = {
	0x20, 0x00,
};

static uint32_t ds954_ix019_stop_setting[] = {
	0x20, 0x30,
};

static uint32_t ds954_ov10635_ix019_init_setting[] = {
	0x01, 0x03,   //  DIGITAL_RESET
	0x1f, 0x02 ,  //  CSI0 800mbps
	0x33, 0x43 ,  // CSI_EN & CSI0 4L
	0x20, 0x30 ,  // forwarding all RX to CSI0

	/* RX_PORT0 */
	0x4c, 0x01 ,   // RX_PORT0
	0x58, 0x58 ,   // enable pass throu
	0x5c, 0x38 ,   // "SER_ALIAS_ID 0x5c value ", hex board.ReadReg 0x5c
	0x5d, 0x60 ,   // "SlaveID[0] 0x5d value ", hex board.ReadReg 0x5d
	0x65, 0x80 ,   // "SlaveAlias[0] 0x65 value ", hex board.ReadReg 0x65
	0x7c, 0x81 ,   // FV low LV high, active upper 8bit
	0x70, 0x1E ,   // VC0 and CSI0 datatype 0x1e yuv422_8b
	0x6d, 0x7F ,   // 913A 10-bit mode, FPD_MODE

	/* RX_PORT1 */
	0x4c, 0x12 ,   // RX_PORT1
	0x58, 0x58 ,   // enable pass throu
	0x5c, 0x3A ,   // "SER_ALIAS_ID 0x5c value ", hex board.ReadReg 0x5c
	0x5d, 0x60 ,   // "SlaveID[0] 0x5d value ", hex board.ReadReg 0x5d
	0x65, 0x80 ,   // "SlaveAlias[0] 0x65 value ", hex board.ReadReg 0x65
	0x7c, 0xC0 ,   // FV && LV high, active low 8bit
	0x70, 0x5E ,   // VC1 and CSI0 datatype 0x1e yuv422_8b
	0xbc, 0x00 ,
	0x6d, 0x7F ,   // 933 10-bit mode, FPD_MODE

	0x6e, 0x18 ,  //  set 954's GPIO1 to 933's GPIO1

    	//  954 GPIO0
	0x0f, 0x7e ,   //  enable GPIO0 output
	0x10, 0xc1 ,   //  enable GPIO0's output with port0's
	// frame valid signal, and then connect 954's GPIO with GPIO1
};

static uint32_t ds954_ov10635_ix019_start_setting[] = {
	0x20, 0x00,
};

static uint32_t ds954_ov10635_ix019_stop_setting[] = {
	0x20, 0x30,
};

static uint32_t ds954_ar0143_ix019_init_setting[] = {
	0x01, 0x03,    // DIGITAL_RESET
	0x1f, 0x02 ,   // CSI0 800mbps
	0x33, 0x43 ,   // CSI_EN & CSI0 4L
	0x20, 0x30 ,   // forwarding all RX to CSI0

	/* RX_PORT0 */
	0x4c, 0x01,
	0x58, 0x58,
	0x5c, 0x38,
	0x7c, 0xC0,
	0x70, 0x1E,
	0xbc, 0x00,
	0x6d, 0x7F,

	/* RX_PORT1 */
	0x4c, 0x12 ,   // RX_PORT1
	0x58, 0x58 ,   // enable pass throu
	0x5c, 0x3A ,   // "SER_ALIAS_ID 0x5c value ", hex board.ReadReg 0x5c
	0x7c, 0xC0 ,   // FV && LV high, active low 8bit
	0x70, 0x5E ,   // VC1 and CSI0 datatype 0x1e yuv422_8b
	0x6d, 0x7F ,   // 933 10-bit mode, FPD_MODE

	0x6e, 0x18 ,  // set 954's GPIO1 to 933's GPIO1

	// 954 GPIO0
	0x0f, 0x7e ,   // enable GPIO0 output
	0x10, 0xc1 ,   // enable GPIO0's output with port0's
	// frame valid signal, and then connect 954's GPIO0 with GPIO1
};

static uint32_t ds954_ar0143_ix019_start_setting[] = {
	0x20, 0x00,
};

static uint32_t ds954_ar0143_ix019_stop_setting[] = {
	0x20, 0x30,
};

static uint32_t ds954_dual_ix019_init_setting[] = {
	0x01, 0x03,    // DIGITAL_RESET
	0x1f, 0x02 ,   // CSI0 800mbps
	0x33, 0x43 ,   // CSI_EN & CSI0 4L
	0x20, 0x30 ,   // forwarding all RX to CSI0

	/* RX_PORT0 */
	0x4c, 0x01,
	0x58, 0x58,
	0x5c, 0x38,
	0x5d, 0x60,
	0x65, 0x80,
	0x7c, 0xC0,
	0x70, 0x1E,
        0xbc, 0x00,
	0x6d, 0x7F,

	/* RX_PORT1 */
	0x4c, 0x12 ,   // RX_PORT1
	0x58, 0x58 ,   // enable pass throu
	0x5c, 0x3A ,   // "SER_ALIAS_ID 0x5c value ", hex board.ReadReg 0x5c
	0x5d, 0x60 ,   // "SlaveID[0] 0x5d value ", hex board.ReadReg 0x5d
	0x65, 0x80 ,   // "SlaveAlias[0] 0x65 value ", hex board.ReadReg 0x65
	0x7c, 0xC0 ,   // FV && LV high, active low 8bit
	0x70, 0x5E ,   // VC1 and CSI0 datatype 0x1e yuv422_8b
	0xbc, 0x00 ,
	0x6d, 0x7F ,   // 933 10-bit mode, FPD_MODE

	0x6e, 0x18 ,   // set 954's GPIO1 to 933's GPIO1

    	// 954 GPIO0
	0x0f, 0x7e ,   // enable GPIO0 output
	0x10, 0xc1 ,   // enable GPIO0's output with port0's
	// frame valid signal, and then connect 954's GPIO0 with GPIO1

	//  0x6e, 0x58

    	//  954 GPIO0
	//	 0x0f, 0x7B ,   //   enable GPIO2 output
	//	 0x12, 0xC1 ,   //   enable GPIO2's output with port0's
	// frame valid signal, and then connect 954's GPIO2 with GPIO5
};

static uint32_t ds954_dual_ix019_start_setting[] = {
	0x20, 0x00,
};

static uint32_t ds954_dual_ix019_stop_setting[] = {
	0x20, 0x30,
};


static uint32_t ds954_mult_v720_init_setting[] = {
	0x1f, 0x03 ,   // CSI0 400mbps
	0x33, 0x41 ,   // CSI_EN & CSI0 4L
	0x20, 0x30 ,   // disable forwarding all RX to CSI0
	//  0x21, 0x3c,

	/* RX_PORT0 10635 */
	0x4c, 0x01 ,   // RX_PORT0
	0x58, 0x58 ,   // enable pass throu
	0x5c, 0x08 ,   // 913 alias addr 0x04
	0x5d, 0x60 ,   // 10635 slave 0x30
	0x65, 0x80 ,   // 10635 alias addr 0x40
	0x7c, 0x81 ,   // FV active low 8bit
	0x70, 0x1E ,   // VC1 and CSI0 datatype 0x1e yuv422_8b
	0x6d, 0xFF ,   // 913A 10-bit mode, FPD_MODE
	0x72, 0x00,

	/* RX_PORT1 10635 */
	0x4c, 0x12 ,  // RX_PORT1
	0x58, 0x58 ,   // enable pass throu
	0x5c, 0x0c ,   // 913 alias addr 0x05
	0x5d, 0x60 ,   // 10635 slave 0x30
	0x65, 0x84 ,   // 10635 alias 0x42
	0x7c, 0x81 ,   // FV active low 8bit
	0x70, 0x5E ,   // VC0 and CSI0 datatype 0x1e yuv422_8b
	0x6d, 0xFF ,   // 913A 10-bit mode, FPD_MODE
	0x72, 0x55,
};
static uint32_t ds954_mult_v720_stream_off[] = {
	0x20, 0x30
};
static uint32_t ds954_mult_v720_stream_on[] = {
	0x20, 0x00
};

static uint32_t ds954_v1080_init_setting[] = {
	0x01, 0x03,     //  DIGITAL_RESET

	0x1f, 0x02,     //  0x02 800Mbps, 0x10 1.6Gbps
	0x33, 0x23,     //  0x0x 4 lanes, 0x2x 2 lanes &
	//  enable csi output & continuous clock
	0x20, 0x30,

	0x4c, 0x01,
	0x58, 0x5e,
	0x6d, 0x7C,
	0x5c, 0x30,
	0x7c, 0x80,
	0x70, 0x1E,
};
static uint32_t ds953_v1080_init_setting[] = {
	0x01, 0x03,	  // d igital reset 0/1
	0x02, 0x33,	  // 4-lane, generator crc, i2c strap mode 1.8v
	0x0E, 0xBC,	  // gpio0/1 output enable
};
static uint32_t ds954_v1080_stream_off[] = {
	0x20, 0x30
};
static uint32_t ds954_v1080_stream_on[] = {
	0x20, 0x00
};

static uint32_t ds954_ar0144AT_init_setting[] = {
	0x01, 0x03,
	0x1f, 0x02,
	0x33, 0x01,
	/***port0***/
	0x4C, 0x01,
	0x5C, 0x30,
	0x5D, 0x20,
	0x65, 0x20,
	0x6E, 0x99,
	0x58, 0x58,
	0x6d, 0x7e,
	0x70, 0x2c,
	/***port1***/
	0x4C, 0x12,
	0x5C, 0x30,
	0x5D, 0x20,
	0x65, 0x20,
	0x6E, 0x99,
	0x58, 0x58,
	0x6d, 0x7e,
	0x70, 0x6c,
	0x20, 0x00
};
#ifdef __cplusplus
}
#endif
#endif
