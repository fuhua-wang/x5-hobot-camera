// Copyright (c) 2024ï¼ŒD-Robotics.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/***************************************************************************
* COPYRIGHT NOTICE
* Copyright 2019 Horizon Robotics, Inc.
* All rights reserved.
***************************************************************************/
#ifndef UTILITY_SENSOR_INC_OVX5BSTD_SETTING_H_
#define UTILITY_SENSOR_INC_OVX5BSTD_SETTING_H_

enum extra_mode_type {
	RAW_TYPE = 0,
	YUV422_TYPE = 1,
};

enum MODE_TYPE {
	SENSING_M24F140D10_S1T7E3,
	SENSING_M24F140D8_S1T7E3,
	MODE_TYPE_MAX,
	MODE_TYPE_NUM,
};

uint32_t max9295_raw_init_setting[] = {
    0x02be, 0x10,//reset
    0x0057, 0x12,    // start pipe Y from B,20
    0x005B, 0x11,
    0x0318, 0x6b,    // set pipe Y Datatype to 0x2c (raw12) raw10 6b  yuv 5e
};

uint32_t max9295_yuv_init_setting[] = {
    0x02be, 0x10,//reset
    0x0057, 0x12,    // start pipe Y from B,20
    0x005B, 0x11,
    0x0318, 0x5e,    // set pipe Y Datatype to 0x2c (raw12) raw10 6b  yuv 5e
};

uint32_t max9296_init_setting[] = {
    0x0320, 0x2F, //MIPI 1200Mbps
};

uint32_t ovx5b_stream_on_setting[] = {
    0x0313, 0x02,
};


uint32_t ovx5b_stream_off_setting[] = {
    0x0313, 0x00,
};

uint32_t ovx5b_raw_init_setting[] = {
//enable sensor i2c address
	0x8006, 0x13,
	0x4698, 0x00,
	0x4699, 0xF8,
//enable raw
	0xd007, 0x2B,
	0xd006, 0x2B,
	0xcc00, 0x74,//bit 2: raw data enable; bit 4:select register setting as output size;
	0x8032, 0xa0,//dupicated raw
	0x8036, 0x00,
	0xc200, 0xFF,
	0xd010, 0x01,
	0xd011, 0x03,
	0xb001, 0xF4,
	0xb003, 0x74,
	0xc2c4, 0x80,
	0xc2c5, 0x07,
	0xc2c6, 0x82,
	0xc2c7, 0x00,
	0xd003, 0x0a,

};

uint32_t ovx5b_yuv_init_setting[] = {
// enable sensor i2c address
	0x8006, 0x13,
	0x4698, 0x00,
	0x4699, 0xF8,

};

uint32_t ovx5b_strobe_setting[] = {
// strobe
	0x3b20, 0xff,
	0x3a9f, 0x08,
	0x3aa0, 0x00,
	0x3aa1, 0x00,
	0x3b21, 0x00,
	0x3b22, 0x00,
	0x3b23, 0x00,
	0x3b24, 0x00,
	0x3b25, 0x00,
	0x3b26, 0x00,
	0x3b27, 0x00,
	0x3b28, 0x00,
	0x3b2f, 0x4a,
	0x3b2d, 0x01,
	0x3b2e, 0x78,
	0x3b1e, 0x01,
	0x3b1f, 0x05,
};

uint32_t rgbir_ovx5b_again[] = {
	0x0100,
	0x0110,
	0x0120,
	0x0130,
	0x0140,
	0x0150,
	0x0160,
	0x0170,
	0x0180,
	0x0190,
	0x01A0,
	0x01B0,
	0x01C0,
	0x01D0,
	0x01E0,
	0x01F0,
	0x0200,
	0x0220,
	0x0240,
	0x0260,
	0x0280,
	0x02A0,
	0x02C0,
	0x02E0,
	0x0300,
	0x0320,
	0x0340,
	0x0360,
	0x0380,
	0x03A0,
	0x03C0,
	0x03E0,
	0x0400,
	0x0440,
	0x0480,
	0x04C0,
	0x0500,
	0x0540,
	0x0580,
	0x05C0,
	0x0600,
	0x0640,
	0x0680,
	0x06C0,
	0x0700,
	0x0740,
	0x0780,
	0x07C0,
	0x0800,
	0x0880,
	0x0900,
	0x0980,
	0x0A00,
	0x0A80,
	0x0B00,
	0x0B80,
	0x0C00,
	0x0C80,
	0x0D00,
	0x0D80,
	0x0E00,
	0x0E80,
	0x0F00,
	0x0F80,
};

uint32_t rgbir_ovx5b_dgain[] = {
	0x0100,
	0x0110,
	0x0120,
	0x0130,
	0x0140,
	0x0150,
	0x0160,
	0x0170,
	0x0180,
	0x0190,
	0x01A0,
	0x01B0,
	0x01C0,
	0x01D0,
	0x01E0,
	0x01F0,
	0x0200,
	0x0220,
	0x0240,
	0x0260,
	0x0280,
	0x02A0,
	0x02C0,
	0x02E0,
	0x0300,
	0x0320,
	0x0340,
	0x0360,
	0x0380,
	0x03A0,
	0x03C0,
	0x03E0,
	0x0400,
	0x0440,
	0x0480,
	0x04C0,
	0x0500,
	0x0540,
	0x0580,
	0x05C0,
	0x0600,
	0x0640,
	0x0680,
	0x06C0,
	0x0700,
	0x0740,
	0x0780,
	0x07C0,
	0x0800,
	0x0880,
	0x0900,
	0x0980,
	0x0A00,
	0x0A80,
	0x0B00,
	0x0B80,
	0x0C00,
	0x0C80,
	0x0D00,
	0x0D80,
	0x0E00,
	0x0E80,
	0x0F00,
	0x0F80,
};


#endif  // UTILITY_SENSOR_INC_OVX8B_SETTING_H_

